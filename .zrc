#!/usr/bin/env zrc
# My personal config (~/.zrc)
# Beware of envvars, stuff that you might not want, etc.
echo "Welcome to Zrc!"
echo "The time is: `{date}"

set __use_unknown = false
fn enable_unknown {
	if {!($__use_unknown)} {
		set __use_unknown = true
		fn unknown {
			expr [arr argv vals]
		}
	} else {
		set __use_unknown = false
		fn unknown
	}
}
enable_unknown

fn title {
	echo -n "\e]0;${argv 1}\a"
}
set __use_title = true
fn enable_title {
	if {!($__use_title)} {
		set __use_title = true
	} else {
		set __use_title = false
		echo "\e]2;\a"
	}
}

fn prompt {
	let {green red rbold reset pwd home lpwd lhome s} {
		set s = $status
		set green = "\e\[0;32m" red = "\e\[0;31m" rbold = "\e\[1;31m" reset = "\e\[0m"
		set pwd = `{pwd} home = [glob -t ~]
		set lpwd = [str $pwd len] lhome = [str $home len]

		# Fit ~ to pwd and set terminal window title
		if {$lhome <= $lpwd} {
			if {[str [str $pwd 0 $lhome-1] == $home]} {
				set pwd = $pwd/
				set pwd = ~[str $pwd $lhome $lpwd]
				set pwd = [str $pwd 0 [str $pwd len]-2]
			}
		}
		if {$__use_title} {
			title "(zrc) $pwd"
		}

		# Part 1: username@hostname
		echo -n $green`{whoami}$reset@`{hostname}
		echo -n ' '
		
		# Part 2: cwd (git branch) [optional status]>
		echo -n ${green}${pwd}
		echo -n ${reset}"`{
			>&- 2 {> 1 /dev/null {git tag}}
			if {!($status)} {
				echo -n " ("
				git branch | grep ^* | colrm 1 2 | tr -d '\n'
				echo -n ")"
			}
		}"
		echo -n "`{
			if {![str `{>& 2 1 expr $s} len]} {
				if {1 <= ($s) && ($s) <= 255} {
					if {[str $last_status != $s]} {
						let {width right pos} {
							set width = `{tput cols}
							set right = :(

							set pos = [expr {$width - [str $right len]}]
							echo -n "\e\[s"                    # Saves cursor position
							echo -n "\e\[${pos}G"              # Move cursor to calculated column
							echo -n "${rbold}${right}${reset}" # Print the frowny
							echo -n "\e\[u"                    # Restore cursor
						}
					}
					echo -n \ $red\[${rbold}${s}${red}\]$reset
				}
			}
		}"'> '
		set last_status = $s
	}
}

bindkey -c "\cl" {
	>& 1 2 eval {
		clear; prompt
	}
}
bindkey -c "\e?" {
	>& 1 2 eval {
		echo && l; prompt
	}
}
bindkey -c "\en" {
	>& 1 2 eval {
		archey3; prompt
	}
}
bindkey -c "\cb"  { firefox & }
bindkey -c "\ct"  { $TERMINAL & }
bindkey -c "\cf"  { doublecmd & }
bindkey -c "\cft" { thunar & }

set __use_lsd = false
fn enable_lsd {
	if {!($__use_lsd) && ![>&- 2 >&- which lsd]} {
		alias ls "lsd"
		alias l "lsd -hF"
		alias lt "lsd -althrF"
		alias la "lsd -all"
		set __use_lsd = true
	} else {
		unalias ls
		alias l "ls -hF --color"
		alias lt "ls -altrhF --color"
		alias la "ls -all"
		set __use_lsd = false
	}
}

fn soundchk { timeout 0.15 aplay /dev/random }
fn life { ffplay -f lavfi -i life }
fn xkcd { $BROWSER https://xkcd.com/${argv 1}}

# Aliases
enable_lsd
alias c       "clear"
alias mkd     "mkdir -pv"
alias rmd     "rmdir -pv"
alias j       "jobs"
alias p       "ps -l"
alias du      "du -k"
alias ..      "cd .."
alias ...     "cd ../.."
alias ....    "cd ../../.."
alias .....   "cd ../../../.."
alias ......  "cd ../../../../.."
alias sha1    "openssl sha1"
alias ports   "netstat -tulanp"
alias net     "\$AUTH systemctl restart NetworkManager"
alias mkdir   "mkdir -pv"
alias pacman  "\$AUTH pacman"
alias calc    "bc -ql"
alias emacs   "emacs -nw"
alias history "eval \$PAGER \[glob -t ~/.zrc_history]"
alias da      "date '+%Y-%m-%d %A %T %Z'"

# Modify original cmds
alias cp      "cp -i"
alias mv      "mv -i"
alias rm      "rm -iv"
alias mkdir   "mkdir -pv"
alias rmdir   "rmdir -pv"
alias ps      "ps auxf"
alias ping    "ping -c 5"

# Chmod alias
alias mx      "chmod a+x"
alias 000     "chmod 000"
alias 644     "chmod 644"
alias 666     "chmod 666"
alias 755     "chmod 755"
alias 777     "chmod 777"

# Ctrl flow
alias forever "while 1"

fn mkcd { mkdir ${argv 1} && cd ${argv 1} }
fn lcd  { cd ${argv 1} && l }

# Rot13 is a very common cipher for some reason
fn rot13 {
	if {$argc == 1} {
		tr '\[a-m]\[n-z]\[A-M]\[N-Z]' '\[n-z]\[a-m]\[N-Z]\[A-M]'
	} else {
		for {set i = 1} {$i < $argc} {inc i} {
			echo ${argv $i}
		} | rot13
	}
}

# go up n times
fn up {
	for {set i = 0} {$i < ${argv 1}} {inc i} ..
}

# Function from Xmodulo
fn kernelgraph {
	lsmod | perl -e {
		print "digraph \"lsmod\" {";
		<>;
		while(<>){
			@_=split/\s+/;
			print "\"$_[0]\" -> \"$_\"\n" for split/,/,$_[3]
		}
		print "}"
	} | dot -Tpng | display -;
}

# Helper function
fn expvar {
	set ${argv 1} = ${argv 2}
	export ${argv 1}
}
expvar AUTH    doas
expvar CDPATH  $CDPATH:$HOME
expvar PATH    /usr/lib/zrc/bin:$HOME/.local/bin:$PATH
expvar PAGER   most
expvar BROWSER firefox
expvar EDITOR  nvim

> /dev/null rehash
set status = 0
